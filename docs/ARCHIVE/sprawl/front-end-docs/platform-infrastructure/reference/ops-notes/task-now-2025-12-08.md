Act as a senior engineer on the OrthodoxMetrics project.

Goal
-----
1. Find and collect ANY existing OCR-related code or assets in this repo.
2. Re-enable and verify the “OCR uploader” flow for record images.
3. Give me a minimal, working end-to-end OCR path:
   - upload image → OCR runs → text/JSON saved or returned → basic verification.

Context
--------
Project root (for this workspace) is:
- /var/www/orthodoxmetrics/prod/front-end

Assume there may also be a backend repo adjacent to this directory (e.g. ../back-end),
but start with this front-end tree and then look for any linked backend calls.

Phase 1 – Discovery (DO THIS FIRST)
-----------------------------------
1) Use ripgrep / project-wide search to find OCR-related code:
   - Search terms: 
     - "OCR", "Ocr", "ocr"
     - "tesseract", "tesseract.js"
     - "vision", "google vision"
     - "ocrUploader", "OCRUploader"
     - "ExtractText", "imageToText", "image2text"
     - "text extraction"
   - Search in:
     - src/
     - scripts/
     - any server or backend folders if present (../back-end, ../server, etc.)

2) Identify:
   - All React/TSX components that mention OCR or uploader logic.
   - Any API clients/hooks that hit OCR endpoints.
   - Any backend endpoints (if present) that perform OCR.
   - Any Python or Node scripts in scripts/ that do OCR (e.g. using pytesseract, Tesseract.js, or external APIs).

3) Output a concise, structured summary:
   - List of files and paths related to OCR.
   - For each file: its role (UI, API client, backend worker, CLI, etc.).
   - Note any dead or obviously outdated code (e.g. references to non-existing endpoints).

Do NOT change any files in this phase. Just analyze and summarize.

Phase 2 – Reconstruct the OCR Uploader Flow
-------------------------------------------
Based on what you find, reconstruct the intended OCR flow:

1) Identify the previous “OCR uploader” UI:
   - Any components named like:
     - OcrUploader, OCRUploader, OcrUpload, ImageOcrUpload, etc.
   - Any routes/menu items that referenced OCR upload pages.

2) If an OCR uploader UI exists:
   - Map its dependencies:
     - Which hooks or services it calls.
     - Which endpoints it calls on the backend.
   - Note any breaking issues:
     - Missing imports, missing endpoints, outdated props.

3) If NO OCR uploader UI exists but you find backend/utility OCR code:
   - Plan a minimal OCR upload UI:
     - Simple page with:
       - file input
       - “Run OCR” button
       - display of extracted text in a textarea or panel.

4) Output a concrete plan:
   - “Here’s the front-end component(s) we will wire up or restore.”
   - “Here’s the endpoint(s) we will call (existing or new).”
   - “Here’s where we will show the OCR result and how we’ll verify it.”

Again, do not edit files yet; just lay out the implementation plan.

Phase 3 – Implementation (Front-end and Backend)
------------------------------------------------
Once the plan is clear, implement the minimal working OCR path.

Front-end:
-----------
1) If an OCR uploader component already exists:
   - Fix imports/types.
   - Fix any broken API calls (URLs, method, payload).
   - Make sure it compiles and can be navigated to.
   - Wire it into Router.tsx and MenuItems.ts under the **Devel Tools** section:
     - New route, e.g. `/devel/ocr-uploader`
     - New menu entry: "OCR Uploader" under Devel Tools pointing to that route.

2) If no suitable component exists, create one:
   - Location: `src/features/ocr/OcrUploader.tsx` (or similar appropriate path for this codebase).
   - Requirements:
     - File input (single image for now).
     - Button: “Run OCR”.
     - While processing, show a spinner / “Processing…” state.
     - After success, show:
       - Extracted text in a scrollable textarea/box.
       - Simple metadata (filename, size).
     - Basic error state handling if OCR fails.

3) Make sure this page is reachable in the app:
   - Add route in Router.tsx.
   - Add menu item in MenuItems.ts under **Devel Tools** group.

Backend / Scripts:
-------------------
Depending on what exists:

A) If there is an existing backend OCR endpoint:
   - Ensure it still builds and runs.
   - Verify that it accepts an image file (multipart/form-data).
   - Confirm response shape (JSON containing recognized text).
   - Fix any obviously broken code or imports.

B) If OCR is implemented via a Python script (e.g. using pytesseract) that is NOT currently wired:
   - Keep the script in place.
   - Implement a minimal Node/Express endpoint (if a backend exists in this project):
     - POST `/api/ocr/extract`
     - Accept a file upload.
     - Call the Python script (child_process or similar) with the uploaded file path.
     - Return JSON: `{ text: "...", metadata: { ... } }`
   - Make sure the front-end uses this endpoint.

C) If no OCR code exists at all:
   - Create the minimal backend OCR endpoint using Tesseract.js in Node OR pytesseract in a Python helper.
   - Keep it small and local to this repo; no external cloud API yet.

Phase 4 – Verification
----------------------
1) Add a minimalist test (or dev-only script) that:
   - Takes a known sample image of a record.
   - Runs the OCR path end-to-end (backend or local script).
   - Logs the extracted text.

2) In the front-end:
   - Ensure the OCR uploader page:
     - Builds.
     - Loads without runtime errors.
     - Successfully calls the OCR endpoint and displays returned text for a test image.

3) Provide in your final response:
   - The list of files you changed (with relative paths).
   - A short, step-by-step “How to use OCR uploader now”:
     - How to start backend (if needed).
     - How to start front-end.
     - Where to click in the UI.
     - What to expect after uploading an image.

Constraints / style
-------------------
- Do not break existing parts of the app; keep OCR changes isolated.
- Prefer small, composable changes over giant refactors.
- Keep naming consistent with the existing codebase conventions.
- Where you introduce new code, keep it clean and typed (TypeScript on front-end, typed JS/TS or clearly typed Python/Node on backend).
- Avoid heavy new dependencies unless absolutely necessary (Tesseract.js or pytesseract is acceptable; avoid random OCR libraries).

Start now with Phase 1 (discovery), show me your findings and plan, then proceed through implementation phases.