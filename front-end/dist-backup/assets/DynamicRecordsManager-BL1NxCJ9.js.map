{"version":3,"file":"DynamicRecordsManager-BL1NxCJ9.js","sources":["../../src/features/records-centralized/components/records/DynamicRecordsApiService.ts","../../src/features/records-centralized/components/records/useDynamicRecords.ts","../../src/features/records-centralized/components/records/DynamicRecordForm.tsx","../../src/features/records-centralized/components/records/DynamicRecordsTable.tsx","../../src/features/records-centralized/components/constants.ts","../../src/features/records-centralized/components/records/DynamicRecordsManager.tsx"],"sourcesContent":["/**\n * Dynamic Records API Service\n * Discovers and works with any om_church_## tables ending in _records\n * Uses column positions instead of field names for display\n */\n\nimport { apiJson, FieldMapperApiError } from '@/sandbox/field-mapper/api/client';\n\n// Types\nexport interface DynamicRecordApiResponse<T> {\n  success: boolean;\n  data?: T;\n  message?: string;\n  error?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  totalPages: number;\n}\n\nexport interface RecordFilters {\n  search?: string;\n  [key: string]: any;\n}\n\nexport interface RecordSort {\n  field: string;\n  direction: 'asc' | 'desc';\n}\n\nexport interface TableSchema {\n  tableName: string;\n  columns: ColumnInfo[];\n  primaryKey: string;\n  displayName: string;\n  recordType: string;\n}\n\nexport interface ColumnInfo {\n  position: number;\n  name: string;\n  type: 'text' | 'number' | 'date' | 'boolean' | 'json';\n  nullable: boolean;\n  defaultValue?: any;\n  isPrimaryKey?: boolean;\n  displayName?: string;\n  width?: number;\n  sortable?: boolean;\n}\n\nexport interface RecordData {\n  [key: string]: any;\n  _columnPositions?: { [position: number]: any };\n  _displayData?: { [position: number]: any };\n}\n\n// API Endpoints\nconst ENDPOINTS = {\n  // Table discovery\n  discoverTables: (churchId: string) => `/api/churches/${churchId}/tables/discover`,\n  getTableSchema: (churchId: string, tableName: string) => `/api/churches/${churchId}/tables/${tableName}/schema`,\n  \n  // Dynamic records CRUD\n  records: (churchId: string, tableName: string) => `/api/churches/${churchId}/tables/${tableName}/records`,\n  recordById: (churchId: string, tableName: string, id: string) => `/api/churches/${churchId}/tables/${tableName}/records/${id}`,\n  \n  // Search and filtering\n  search: (churchId: string, tableName: string) => `/api/churches/${churchId}/tables/${tableName}/search`,\n  \n  // Import/Export\n  import: (churchId: string, tableName: string) => `/api/churches/${churchId}/tables/${tableName}/import`,\n  export: (churchId: string, tableName: string) => `/api/churches/${churchId}/tables/${tableName}/export`,\n  \n  // Utilities\n  dropdownOptions: (churchId: string) => `/api/churches/${churchId}/dropdown-options`,\n  healthCheck: () => '/api/health',\n} as const;\n\nclass DynamicRecordsApiService {\n  private churchId: string;\n  private tableCache: Map<string, TableSchema> = new Map();\n\n  constructor(churchId: string) {\n    this.churchId = churchId;\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // TABLE DISCOVERY\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Discover all record tables for this church\n   */\n  async discoverRecordTables(): Promise<DynamicRecordApiResponse<TableSchema[]>> {\n    try {\n      const data = await apiJson<TableSchema[]>(ENDPOINTS.discoverTables(this.churchId));\n      \n      // Cache the table schemas\n      data.forEach(table => {\n        this.tableCache.set(table.tableName, table);\n      });\n      \n      return {\n        success: true,\n        data,\n        message: `Discovered ${data.length} record tables`\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to discover record tables');\n    }\n  }\n\n  /**\n   * Get schema for a specific table\n   */\n  async getTableSchema(tableName: string): Promise<DynamicRecordApiResponse<TableSchema>> {\n    try {\n      // Check cache first\n      if (this.tableCache.has(tableName)) {\n        return {\n          success: true,\n          data: this.tableCache.get(tableName)!,\n          message: 'Table schema retrieved from cache'\n        };\n      }\n\n      const data = await apiJson<TableSchema>(ENDPOINTS.getTableSchema(this.churchId, tableName));\n      \n      // Cache the schema\n      this.tableCache.set(tableName, data);\n      \n      return {\n        success: true,\n        data,\n        message: 'Table schema retrieved successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to retrieve table schema');\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // DYNAMIC RECORDS CRUD OPERATIONS\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Get all records for a specific table\n   */\n  async getRecords(\n    tableName: string,\n    filters?: RecordFilters,\n    sort?: RecordSort,\n    pagination?: { page: number; limit: number }\n  ): Promise<DynamicRecordApiResponse<PaginatedResponse<RecordData>>> {\n    try {\n      const params = new URLSearchParams();\n      \n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== null && value !== '') {\n            params.append(key, value.toString());\n          }\n        });\n      }\n      \n      if (sort) {\n        params.append('sortBy', sort.field);\n        params.append('sortOrder', sort.direction);\n      }\n      \n      if (pagination) {\n        params.append('page', pagination.page.toString());\n        params.append('limit', pagination.limit.toString());\n      }\n\n      const url = `${ENDPOINTS.records(this.churchId, tableName)}?${params.toString()}`;\n      const data = await apiJson<PaginatedResponse<RecordData>>(url);\n      \n      // Transform data to include column position information\n      const transformedData = {\n        ...data,\n        data: data.data.map(record => this.transformRecordData(record, tableName))\n      };\n      \n      return {\n        success: true,\n        data: transformedData,\n        message: 'Records retrieved successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to retrieve records');\n    }\n  }\n\n  /**\n   * Get a single record by ID\n   */\n  async getRecord(\n    tableName: string,\n    id: string\n  ): Promise<DynamicRecordApiResponse<RecordData>> {\n    try {\n      const data = await apiJson<RecordData>(ENDPOINTS.recordById(this.churchId, tableName, id));\n      \n      return {\n        success: true,\n        data: this.transformRecordData(data, tableName),\n        message: 'Record retrieved successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to retrieve record');\n    }\n  }\n\n  /**\n   * Create a new record\n   */\n  async createRecord(\n    tableName: string,\n    recordData: Partial<RecordData>\n  ): Promise<DynamicRecordApiResponse<RecordData>> {\n    try {\n      const data = await apiJson<RecordData>(ENDPOINTS.records(this.churchId, tableName), {\n        method: 'POST',\n        body: JSON.stringify(recordData)\n      });\n      \n      return {\n        success: true,\n        data: this.transformRecordData(data, tableName),\n        message: 'Record created successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to create record');\n    }\n  }\n\n  /**\n   * Update an existing record\n   */\n  async updateRecord(\n    tableName: string,\n    id: string,\n    recordData: Partial<RecordData>\n  ): Promise<DynamicRecordApiResponse<RecordData>> {\n    try {\n      const data = await apiJson<RecordData>(ENDPOINTS.recordById(this.churchId, tableName, id), {\n        method: 'PUT',\n        body: JSON.stringify(recordData)\n      });\n      \n      return {\n        success: true,\n        data: this.transformRecordData(data, tableName),\n        message: 'Record updated successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to update record');\n    }\n  }\n\n  /**\n   * Delete a record\n   */\n  async deleteRecord(\n    tableName: string,\n    id: string\n  ): Promise<DynamicRecordApiResponse<void>> {\n    try {\n      await apiJson<void>(ENDPOINTS.recordById(this.churchId, tableName, id), {\n        method: 'DELETE'\n      });\n      \n      return {\n        success: true,\n        message: 'Record deleted successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to delete record');\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // SEARCH AND FILTERING\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Search records with advanced filtering\n   */\n  async searchRecords(\n    tableName: string,\n    searchTerm: string,\n    filters?: RecordFilters,\n    sort?: RecordSort,\n    pagination?: { page: number; limit: number }\n  ): Promise<DynamicRecordApiResponse<PaginatedResponse<RecordData>>> {\n    try {\n      const params = new URLSearchParams();\n      params.append('q', searchTerm);\n      \n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== null && value !== '') {\n            params.append(key, value.toString());\n          }\n        });\n      }\n      \n      if (sort) {\n        params.append('sortBy', sort.field);\n        params.append('sortOrder', sort.direction);\n      }\n      \n      if (pagination) {\n        params.append('page', pagination.page.toString());\n        params.append('limit', pagination.limit.toString());\n      }\n\n      const url = `${ENDPOINTS.search(this.churchId, tableName)}?${params.toString()}`;\n      const data = await apiJson<PaginatedResponse<RecordData>>(url);\n      \n      // Transform data to include column position information\n      const transformedData = {\n        ...data,\n        data: data.data.map(record => this.transformRecordData(record, tableName))\n      };\n      \n      return {\n        success: true,\n        data: transformedData,\n        message: 'Search completed successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to search records');\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // IMPORT/EXPORT OPERATIONS\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Import records from file\n   */\n  async importRecords(\n    tableName: string,\n    file: File,\n    options?: { mapping?: any; skipValidation?: boolean }\n  ): Promise<DynamicRecordApiResponse<{ imported: number; errors: any[] }>> {\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      if (options?.mapping) {\n        formData.append('mapping', JSON.stringify(options.mapping));\n      }\n      \n      if (options?.skipValidation) {\n        formData.append('skipValidation', 'true');\n      }\n\n      const data = await apiJson<{ imported: number; errors: any[] }>(\n        ENDPOINTS.import(this.churchId, tableName),\n        {\n          method: 'POST',\n          body: formData\n        }\n      );\n      \n      return {\n        success: true,\n        data,\n        message: `Successfully imported ${data.imported} records`\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to import records');\n    }\n  }\n\n  /**\n   * Export records to file\n   */\n  async exportRecords(\n    tableName: string,\n    format: 'csv' | 'pdf' | 'excel',\n    filters?: RecordFilters\n  ): Promise<DynamicRecordApiResponse<Blob>> {\n    try {\n      const params = new URLSearchParams();\n      params.append('format', format);\n      \n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== null && value !== '') {\n            params.append(key, value.toString());\n          }\n        });\n      }\n\n      const url = `${ENDPOINTS.export(this.churchId, tableName)}?${params.toString()}`;\n      const response = await fetch(url, {\n        headers: {\n          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Export failed: ${response.statusText}`);\n      }\n      \n      const blob = await response.blob();\n      \n      return {\n        success: true,\n        data: blob,\n        message: 'Records exported successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to export records');\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // UTILITY OPERATIONS\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Get dropdown options for forms\n   */\n  async getDropdownOptions(): Promise<DynamicRecordApiResponse<any>> {\n    try {\n      const data = await apiJson<any>(ENDPOINTS.dropdownOptions(this.churchId));\n      \n      return {\n        success: true,\n        data,\n        message: 'Dropdown options retrieved successfully'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Failed to retrieve dropdown options');\n    }\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck(): Promise<DynamicRecordApiResponse<{ status: string; timestamp: string }>> {\n    try {\n      const data = await apiJson<{ status: string; timestamp: string }>(ENDPOINTS.healthCheck());\n      \n      return {\n        success: true,\n        data,\n        message: 'Health check completed'\n      };\n    } catch (error) {\n      return this.handleError(error, 'Health check failed');\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // DATA TRANSFORMATION\n  // ═══════════════════════════════════════════════════════════════\n\n  /**\n   * Transform record data to include column position information\n   */\n  private transformRecordData(record: RecordData, tableName: string): RecordData {\n    const schema = this.tableCache.get(tableName);\n    if (!schema) {\n      return record;\n    }\n\n    const transformedRecord = { ...record };\n    const columnPositions: { [position: number]: any } = {};\n    const displayData: { [position: number]: any } = {};\n\n    // Map data by column position\n    schema.columns.forEach(column => {\n      const value = record[column.name];\n      columnPositions[column.position] = value;\n      \n      // Format display data based on column type\n      displayData[column.position] = this.formatDisplayValue(value, column);\n    });\n\n    transformedRecord._columnPositions = columnPositions;\n    transformedRecord._displayData = displayData;\n\n    return transformedRecord;\n  }\n\n  /**\n   * Format display value based on column type\n   */\n  private formatDisplayValue(value: any, column: ColumnInfo): string {\n    if (value === null || value === undefined) {\n      return 'N/A';\n    }\n\n    switch (column.type) {\n      case 'date':\n        return new Date(value).toLocaleDateString();\n      case 'number':\n        return value.toString();\n      case 'boolean':\n        return value ? 'Yes' : 'No';\n      case 'json':\n        return typeof value === 'string' ? value : JSON.stringify(value);\n      default:\n        return String(value);\n    }\n  }\n\n  // ═══════════════════════════════════════════════════════════════\n  // ERROR HANDLING\n  // ═══════════════════════════════════════════════════════════════\n\n  private handleError(error: any, defaultMessage: string): DynamicRecordApiResponse<any> {\n    console.error('Dynamic Records API Error:', error);\n    \n    let message = defaultMessage;\n    let errorCode = 'UNKNOWN_ERROR';\n    \n    if (error instanceof FieldMapperApiError) {\n      message = error.apiError.message;\n      errorCode = error.apiError.code || 'API_ERROR';\n    } else if (error instanceof Error) {\n      message = error.message;\n    }\n    \n    return {\n      success: false,\n      error: message,\n      message: `Error: ${message}`\n    };\n  }\n}\n\n// Factory function to create service instance\nexport const createDynamicRecordsApiService = (churchId: string) => new DynamicRecordsApiService(churchId);\n\n// Export singleton for default church (if available)\nexport const dynamicRecordsApiService = createDynamicRecordsApiService('default');\n\nexport default DynamicRecordsApiService;\n","/**\n * Dynamic hooks for any record table\n * Works with om_church_## tables ending in _records\n * Uses column positions instead of field names\n */\n\nimport { useState, useCallback, useMemo } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { \n  createDynamicRecordsApiService, \n  RecordFilters, \n  RecordSort, \n  PaginatedResponse,\n  TableSchema,\n  RecordData \n} from './DynamicRecordsApiService';\n\n// Query keys for consistent caching\nconst QUERY_KEYS = {\n  tables: (churchId: string) => ['dynamic-tables', churchId],\n  tableSchema: (churchId: string, tableName: string) => ['table-schema', churchId, tableName],\n  records: (churchId: string, tableName: string, filters?: RecordFilters, sort?: RecordSort, pagination?: any) => \n    ['dynamic-records', churchId, tableName, filters, sort, pagination],\n  record: (churchId: string, tableName: string, id: string) => \n    ['dynamic-record', churchId, tableName, id],\n  dropdownOptions: (churchId: string) => ['dropdown-options', churchId],\n} as const;\n\n/**\n * Hook for discovering available record tables\n */\nexport function useRecordTables(churchId: string) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    refetch\n  } = useQuery({\n    queryKey: QUERY_KEYS.tables(churchId),\n    queryFn: () => apiService.discoverRecordTables(),\n    enabled: !!churchId,\n    staleTime: 10 * 60 * 1000, // 10 minutes\n    retry: 2,\n  });\n\n  return {\n    tables: data?.data || [],\n    isLoading,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for getting table schema\n */\nexport function useTableSchema(churchId: string, tableName: string) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    refetch\n  } = useQuery({\n    queryKey: QUERY_KEYS.tableSchema(churchId, tableName),\n    queryFn: () => apiService.getTableSchema(tableName),\n    enabled: !!churchId && !!tableName,\n    staleTime: 15 * 60 * 1000, // 15 minutes\n    retry: 2,\n  });\n\n  return {\n    schema: data?.data,\n    isLoading,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for managing records with pagination, filtering, and sorting\n */\nexport function useDynamicRecords(\n  churchId: string,\n  tableName: string,\n  options: {\n    filters?: RecordFilters;\n    sort?: RecordSort;\n    pagination?: { page: number; limit: number };\n    enabled?: boolean;\n  } = {}\n) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    isFetching,\n    refetch\n  } = useQuery({\n    queryKey: QUERY_KEYS.records(churchId, tableName, options.filters, options.sort, options.pagination),\n    queryFn: () => apiService.getRecords(tableName, options.filters, options.sort, options.pagination),\n    enabled: options.enabled !== false && !!churchId && !!tableName,\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    retry: 2,\n  });\n\n  return {\n    records: data?.data?.data || [],\n    total: data?.data?.total || 0,\n    page: data?.data?.page || 1,\n    totalPages: data?.data?.totalPages || 0,\n    isLoading,\n    isFetching,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for managing a single record\n */\nexport function useDynamicRecord(\n  churchId: string,\n  tableName: string,\n  recordId: string,\n  options: { enabled?: boolean } = {}\n) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    refetch\n  } = useQuery({\n    queryKey: QUERY_KEYS.record(churchId, tableName, recordId),\n    queryFn: () => apiService.getRecord(tableName, recordId),\n    enabled: options.enabled !== false && !!churchId && !!tableName && !!recordId,\n    staleTime: 5 * 60 * 1000,\n  });\n\n  return {\n    record: data?.data,\n    isLoading,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for record mutations (create, update, delete)\n */\nexport function useDynamicRecordMutations(\n  churchId: string,\n  tableName: string\n) {\n  const queryClient = useQueryClient();\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n\n  // Create mutation\n  const createMutation = useMutation({\n    mutationFn: (recordData: Partial<RecordData>) => apiService.createRecord(tableName, recordData),\n    onSuccess: () => {\n      // Invalidate and refetch records\n      queryClient.invalidateQueries({ \n        queryKey: QUERY_KEYS.records(churchId, tableName) \n      });\n    },\n  });\n\n  // Update mutation\n  const updateMutation = useMutation({\n    mutationFn: ({ id, data }: { id: string; data: Partial<RecordData> }) => \n      apiService.updateRecord(tableName, id, data),\n    onSuccess: (_, { id }) => {\n      // Invalidate records and specific record\n      queryClient.invalidateQueries({ \n        queryKey: QUERY_KEYS.records(churchId, tableName) \n      });\n      queryClient.invalidateQueries({ \n        queryKey: QUERY_KEYS.record(churchId, tableName, id) \n      });\n    },\n  });\n\n  // Delete mutation\n  const deleteMutation = useMutation({\n    mutationFn: (id: string) => apiService.deleteRecord(tableName, id),\n    onSuccess: () => {\n      // Invalidate records\n      queryClient.invalidateQueries({ \n        queryKey: QUERY_KEYS.records(churchId, tableName) \n      });\n    },\n  });\n\n  return {\n    create: createMutation,\n    update: updateMutation,\n    delete: deleteMutation,\n  };\n}\n\n/**\n * Hook for search functionality\n */\nexport function useDynamicRecordSearch(\n  churchId: string,\n  tableName: string,\n  searchTerm: string,\n  options: {\n    filters?: RecordFilters;\n    sort?: RecordSort;\n    pagination?: { page: number; limit: number };\n    enabled?: boolean;\n  } = {}\n) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    isFetching,\n    refetch\n  } = useQuery({\n    queryKey: ['dynamic-search', churchId, tableName, searchTerm, options.filters, options.sort, options.pagination],\n    queryFn: () => apiService.searchRecords(\n      tableName, \n      searchTerm, \n      options.filters, \n      options.sort, \n      options.pagination\n    ),\n    enabled: (options.enabled !== false) && !!churchId && !!tableName && !!searchTerm.trim(),\n    staleTime: 2 * 60 * 1000, // 2 minutes for search results\n  });\n\n  return {\n    results: data?.data?.data || [],\n    total: data?.data?.total || 0,\n    page: data?.data?.page || 1,\n    totalPages: data?.data?.totalPages || 0,\n    isLoading,\n    isFetching,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for import/export operations\n */\nexport function useDynamicRecordImportExport(churchId: string, tableName: string) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  const queryClient = useQueryClient();\n\n  // Import mutation\n  const importMutation = useMutation({\n    mutationFn: ({ file, options }: { file: File; options?: any }) => \n      apiService.importRecords(tableName, file, options),\n    onSuccess: () => {\n      // Invalidate records after import\n      queryClient.invalidateQueries({ \n        queryKey: QUERY_KEYS.records(churchId, tableName) \n      });\n    },\n  });\n\n  // Export mutation\n  const exportMutation = useMutation({\n    mutationFn: ({ format, filters }: { format: 'csv' | 'pdf' | 'excel'; filters?: RecordFilters }) => \n      apiService.exportRecords(tableName, format, filters),\n  });\n\n  return {\n    import: importMutation,\n    export: exportMutation,\n  };\n}\n\n/**\n * Hook for dropdown options\n */\nexport function useDynamicDropdownOptions(churchId: string) {\n  const apiService = useMemo(() => createDynamicRecordsApiService(churchId), [churchId]);\n  \n  const {\n    data,\n    error,\n    isLoading,\n    refetch\n  } = useQuery({\n    queryKey: QUERY_KEYS.dropdownOptions(churchId),\n    queryFn: () => apiService.getDropdownOptions(),\n    enabled: !!churchId,\n    staleTime: 15 * 60 * 1000, // 15 minutes\n  });\n\n  return {\n    options: data?.data || {},\n    isLoading,\n    error: error || data?.error,\n    refetch,\n    success: data?.success || false,\n  };\n}\n\n/**\n * Hook for generating table columns from schema\n */\nexport function useTableColumns(churchId: string, tableName: string) {\n  const { schema, isLoading, error } = useTableSchema(churchId, tableName);\n\n  const columns = useMemo(() => {\n    if (!schema) return [];\n\n    return schema.columns\n      .filter(column => !column.isPrimaryKey) // Exclude primary key from display\n      .sort((a, b) => a.position - b.position) // Sort by position\n      .map(column => ({\n        key: `col_${column.position}`,\n        label: column.displayName || column.name,\n        width: column.width || 'auto',\n        sortable: column.sortable !== false,\n        position: column.position,\n        type: column.type,\n        render: (value: any, record: RecordData) => {\n          // Use column position data if available\n          if (record._displayData && record._displayData[column.position] !== undefined) {\n            return record._displayData[column.position];\n          }\n          \n          // Fallback to column name\n          const columnValue = record[column.name];\n          return formatDisplayValue(columnValue, column);\n        },\n      }));\n  }, [schema]);\n\n  return {\n    columns,\n    isLoading,\n    error,\n    schema,\n  };\n}\n\n/**\n * Hook for generating form fields from schema\n */\nexport function useFormFields(churchId: string, tableName: string) {\n  const { schema, isLoading, error } = useTableSchema(churchId, tableName);\n\n  const fields = useMemo(() => {\n    if (!schema) return [];\n\n    return schema.columns\n      .filter(column => !column.isPrimaryKey) // Exclude primary key from form\n      .sort((a, b) => a.position - b.position) // Sort by position\n      .map(column => ({\n        key: column.name,\n        label: column.displayName || column.name,\n        type: mapColumnTypeToFormType(column.type),\n        required: !column.nullable,\n        placeholder: `Enter ${column.displayName || column.name.toLowerCase()}`,\n        gridSize: { xs: 12, sm: 6, md: 4 },\n        position: column.position,\n      }));\n  }, [schema]);\n\n  return {\n    fields,\n    isLoading,\n    error,\n    schema,\n  };\n}\n\n/**\n * Hook for generating search filters from schema\n */\nexport function useSearchFilters(churchId: string, tableName: string) {\n  const { schema, isLoading, error } = useTableSchema(churchId, tableName);\n\n  const filters = useMemo(() => {\n    if (!schema) return [];\n\n    return schema.columns\n      .filter(column => \n        !column.isPrimaryKey && \n        (column.type === 'text' || column.type === 'date' || column.type === 'number')\n      )\n      .sort((a, b) => a.position - b.position)\n      .map(column => ({\n        key: column.name,\n        label: column.displayName || column.name,\n        type: mapColumnTypeToFilterType(column.type),\n        position: column.position,\n      }));\n  }, [schema]);\n\n  return {\n    filters,\n    isLoading,\n    error,\n    schema,\n  };\n}\n\n// ═══════════════════════════════════════════════════════════════\n// UTILITY FUNCTIONS\n// ═══════════════════════════════════════════════════════════════\n\nfunction formatDisplayValue(value: any, column: any): string {\n  if (value === null || value === undefined) {\n    return 'N/A';\n  }\n\n  switch (column.type) {\n    case 'date':\n      return new Date(value).toLocaleDateString();\n    case 'number':\n      return value.toString();\n    case 'boolean':\n      return value ? 'Yes' : 'No';\n    case 'json':\n      return typeof value === 'string' ? value : JSON.stringify(value);\n    default:\n      return String(value);\n  }\n}\n\nfunction mapColumnTypeToFormType(columnType: string): string {\n  switch (columnType) {\n    case 'date':\n      return 'date';\n    case 'number':\n      return 'number';\n    case 'boolean':\n      return 'switch';\n    case 'json':\n      return 'textarea';\n    default:\n      return 'text';\n  }\n}\n\nfunction mapColumnTypeToFilterType(columnType: string): string {\n  switch (columnType) {\n    case 'date':\n      return 'date';\n    case 'number':\n      return 'text';\n    default:\n      return 'text';\n  }\n}\n","import React from 'react';\n\ninterface DynamicRecordFormProps {\n  churchId: string;\n  tableName: string;\n  onSave: (record: any) => void;\n  onCancel: () => void;\n}\n\nconst DynamicRecordForm = ({ churchId, tableName, onSave, onCancel }: DynamicRecordFormProps) => {\n  return (\n    <div>\n      <h3>Dynamic Record Form</h3>\n      <p>Church ID: {churchId}</p>\n      <p>Table: {tableName}</p>\n      <button onClick={() => onSave({})}>Save</button>\n      <button onClick={onCancel}>Cancel</button>\n    </div>\n  );\n};\n\nexport default DynamicRecordForm;\n","/**\n * Dynamic Records Table Component\n * Works with any table schema using column positions\n */\n\nimport React, { useState, useMemo } from 'react';\nimport { motion } from 'framer-motion';\nimport {\n  Table,\n  TableBody,\n  TableHead,\n  \n  TableRow,\n  TableCell,\n  TableContainer,\n  Paper,\n  Skeleton,\n  IconButton,\n  Tooltip,\n  Chip,\n  Box,\n  Typography,\n  Checkbox,\n  Menu,\n  MenuItem,\n  ListItemIcon,\n  ListItemText,\n  Alert,\n} from '@mui/material';\nimport {\n  MoreVert as MoreIcon,\n  Edit as EditIcon,\n  Delete as DeleteIcon,\n  Visibility as ViewIcon,\n  History as HistoryIcon,\n  FileDownload as DownloadIcon,\n  Refresh as RefreshIcon,\n} from '@mui/icons-material';\n\n// Types\nexport interface DynamicTableColumn {\n  key: string;\n  label: string;\n  width?: string | number;\n  align?: 'left' | 'center' | 'right';\n  sortable?: boolean;\n  position: number;\n  type: string;\n  render?: (value: any, record: any) => React.ReactNode;\n}\n\nexport interface DynamicRecordsTableProps {\n  records: any[];\n  columns: DynamicTableColumn[];\n  loading?: boolean;\n  error?: string | null;\n  selectedRecords?: string[];\n  onRecordSelect?: (recordId: string, selected: boolean) => void;\n  onSelectAll?: (selected: boolean) => void;\n  onRecordAction?: (action: string, record: any) => void;\n  onSort?: (field: string, direction: 'asc' | 'desc') => void;\n  sortField?: string;\n  sortDirection?: 'asc' | 'desc';\n  actions?: Array<{\n    key: string;\n    label: string;\n    icon: React.ReactNode;\n    color?: 'primary' | 'secondary' | 'error' | 'warning' | 'info' | 'success';\n    disabled?: (record: any) => boolean;\n  }>;\n  emptyMessage?: string;\n  className?: string;\n  showCheckboxes?: boolean;\n  showActions?: boolean;\n  dense?: boolean;\n  stickyHeader?: boolean;\n  maxHeight?: number;\n  primaryKeyField?: string;\n}\n\nexport function DynamicRecordsTable({\n  records,\n  columns,\n  loading = false,\n  error = null,\n  selectedRecords = [],\n  onRecordSelect,\n  onSelectAll,\n  onRecordAction,\n  onSort,\n  sortField,\n  sortDirection = 'asc',\n  actions = [],\n  emptyMessage = 'No records found',\n  className = '',\n  showCheckboxes = false,\n  showActions = true,\n  dense = false,\n  stickyHeader = true,\n  maxHeight = 600,\n  primaryKeyField = 'id',\n}: DynamicRecordsTableProps) {\n  const [anchorEl, setAnchorEl] = useState<{ [key: string]: HTMLElement | null }>({});\n\n  // Handle sort\n  const handleSort = (field: string) => {\n    if (!onSort) return;\n    \n    const newDirection = sortField === field && sortDirection === 'asc' ? 'desc' : 'asc';\n    onSort(field, newDirection);\n  };\n\n  // Handle action menu\n  const handleActionClick = (event: React.MouseEvent<HTMLElement>, recordId: string) => {\n    setAnchorEl(prev => ({ ...prev, [recordId]: event.currentTarget }));\n  };\n\n  const handleActionClose = (recordId: string) => {\n    setAnchorEl(prev => ({ ...prev, [recordId]: null }));\n  };\n\n  const handleActionSelect = (action: string, record: any) => {\n    onRecordAction?.(action, record);\n    // Close all menus\n    setAnchorEl({});\n  };\n\n  // Handle selection\n  const handleRecordSelect = (recordId: string, selected: boolean) => {\n    onRecordSelect?.(recordId, selected);\n  };\n\n  const handleSelectAll = (selected: boolean) => {\n    onSelectAll?.(selected);\n  };\n\n  // Get record ID (try multiple possible fields)\n  const getRecordId = (record: any): string => {\n    return record[primaryKeyField] || \n           record.id || \n           record._id || \n           record[`${primaryKeyField}_id`] ||\n           String(record._columnPositions?.[0] || '');\n  };\n\n  // Check if all records are selected\n  const allSelected = records.length > 0 && selectedRecords.length === records.length;\n  const someSelected = selectedRecords.length > 0 && selectedRecords.length < records.length;\n\n  // Sort columns by position\n  const sortedColumns = useMemo(() => {\n    return [...columns].sort((a, b) => a.position - b.position);\n  }, [columns]);\n\n  // Loading skeleton\n  if (loading) {\n    return <DynamicRecordsTableSkeleton columns={columns.length} rows={10} />;\n  }\n\n  // Error state\n  if (error) {\n    return (\n      <Box sx={{ p: 3, textAlign: 'center' }}>\n        <Alert severity=\"error\">\n          {error}\n        </Alert>\n      </Box>\n    );\n  }\n\n  // Empty state\n  if (records.length === 0) {\n    return (\n      <Box sx={{ p: 3, textAlign: 'center' }}>\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          {emptyMessage}\n        </Typography>\n      </Box>\n    );\n  }\n\n  return (\n    <TableContainer \n      component={Paper} \n      sx={{ \n        maxHeight: stickyHeader ? maxHeight : undefined,\n        borderRadius: 2,\n        boxShadow: 1,\n      }}\n      className={className}\n    >\n      <Table stickyHeader={stickyHeader} size={dense ? 'small' : 'medium'}>\n        <TableHead>\n          <TableRow>\n            {showCheckboxes && (\n              <TableCell padding=\"checkbox\">\n                <Checkbox\n                  indeterminate={someSelected}\n                  checked={allSelected}\n                  onChange={(e) => handleSelectAll(e.target.checked)}\n                />\n              </TableCell>\n            )}\n            {sortedColumns.map((column) => (\n              <TableCell\n                key={column.key}\n                align={column.align || 'left'}\n                sx={{\n                  width: column.width,\n                  cursor: column.sortable ? 'pointer' : 'default',\n                  userSelect: 'none',\n                  fontWeight: 600,\n                  backgroundColor: 'grey.50',\n                }}\n                onClick={() => column.sortable && handleSort(column.key)}\n              >\n                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n                  {column.label}\n                  {column.sortable && sortField === column.key && (\n                    <Chip\n                      label={sortDirection === 'asc' ? '↑' : '↓'}\n                      size=\"small\"\n                      color=\"primary\"\n                      variant=\"outlined\"\n                    />\n                  )}\n                </Box>\n              </TableCell>\n            ))}\n            {showActions && actions.length > 0 && (\n              <TableCell align=\"right\" sx={{ width: 60, backgroundColor: 'grey.50' }}>\n                Actions\n              </TableCell>\n            )}\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {records.map((record, index) => {\n            const recordId = getRecordId(record);\n            const isSelected = selectedRecords.includes(recordId);\n            const menuAnchor = anchorEl[recordId];\n\n            return (\n              <motion.tr\n                key={recordId}\n                initial={{ opacity: 0, y: 20 }}\n                animate={{ opacity: 1, y: 0 }}\n                transition={{ delay: index * 0.05 }}\n                asChild\n              >\n                <TableRow\n                  hover\n                  selected={isSelected}\n                  sx={{\n                    '&:nth-of-type(odd)': {\n                      backgroundColor: 'grey.50',\n                    },\n                    '&:hover': {\n                      backgroundColor: 'action.hover',\n                    },\n                  }}\n                >\n                  {showCheckboxes && (\n                    <TableCell padding=\"checkbox\">\n                      <Checkbox\n                        checked={isSelected}\n                        onChange={(e) => handleRecordSelect(recordId, e.target.checked)}\n                      />\n                    </TableCell>\n                  )}\n                  {sortedColumns.map((column) => {\n                    const value = column.render \n                      ? column.render(null, record)\n                      : getColumnValue(record, column);\n\n                    return (\n                      <TableCell\n                        key={column.key}\n                        align={column.align || 'left'}\n                        sx={{ width: column.width }}\n                      >\n                        {value}\n                      </TableCell>\n                    );\n                  })}\n                  {showActions && actions.length > 0 && (\n                    <TableCell align=\"right\">\n                      <IconButton\n                        size=\"small\"\n                        onClick={(e) => handleActionClick(e, recordId)}\n                      >\n                        <MoreIcon />\n                      </IconButton>\n                      <Menu\n                        anchorEl={menuAnchor}\n                        open={Boolean(menuAnchor)}\n                        onClose={() => handleActionClose(recordId)}\n                        anchorOrigin={{\n                          vertical: 'bottom',\n                          horizontal: 'right',\n                        }}\n                        transformOrigin={{\n                          vertical: 'top',\n                          horizontal: 'right',\n                        }}\n                      >\n                        {actions.map((action) => {\n                          const isDisabled = action.disabled?.(record) || false;\n                          \n                          return (\n                            <MenuItem\n                              key={action.key}\n                              onClick={() => handleActionSelect(action.key, record)}\n                              disabled={isDisabled}\n                              sx={{\n                                color: isDisabled ? 'text.disabled' : `${action.color}.main`,\n                              }}\n                            >\n                              <ListItemIcon>\n                                {action.icon}\n                              </ListItemIcon>\n                              <ListItemText>{action.label}</ListItemText>\n                            </MenuItem>\n                          );\n                        })}\n                      </Menu>\n                    </TableCell>\n                  )}\n                </TableRow>\n              </motion.tr>\n            );\n          })}\n        </TableBody>\n      </Table>\n    </TableContainer>\n  );\n}\n\n/**\n * Get column value from record using position or name\n */\nfunction getColumnValue(record: any, column: DynamicTableColumn): any {\n  // Try to get value by column position first\n  if (record._displayData && record._displayData[column.position] !== undefined) {\n    return record._displayData[column.position];\n  }\n  \n  if (record._columnPositions && record._columnPositions[column.position] !== undefined) {\n    return formatValue(record._columnPositions[column.position], column.type);\n  }\n  \n  // Fallback to column name\n  const columnName = column.key.replace('col_', '');\n  const value = record[columnName];\n  return formatValue(value, column.type);\n}\n\n/**\n * Format value based on column type\n */\nfunction formatValue(value: any, type: string): string {\n  if (value === null || value === undefined) {\n    return 'N/A';\n  }\n\n  switch (type) {\n    case 'date':\n      return new Date(value).toLocaleDateString();\n    case 'number':\n      return value.toString();\n    case 'boolean':\n      return value ? 'Yes' : 'No';\n    case 'json':\n      return typeof value === 'string' ? value : JSON.stringify(value);\n    default:\n      return String(value);\n  }\n}\n\n/**\n * Loading skeleton for dynamic records table\n */\nexport function DynamicRecordsTableSkeleton({ \n  columns = 5, \n  rows = 10 \n}: { \n  columns?: number; \n  rows?: number; \n}) {\n  return (\n    <TableContainer component={Paper} sx={{ borderRadius: 2, boxShadow: 1 }}>\n      <Table>\n        <TableHead>\n          <TableRow>\n            {Array.from({ length: columns }).map((_, index) => (\n              <TableCell key={index}>\n                <Skeleton animation=\"wave\" width=\"100%\" height={24} />\n              </TableCell>\n            ))}\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {Array.from({ length: rows }).map((_, rowIndex) => (\n            <TableRow key={rowIndex}>\n              {Array.from({ length: columns }).map((_, colIndex) => (\n                <TableCell key={colIndex}>\n                  <Skeleton \n                    animation=\"wave\" \n                    width={colIndex === 0 ? 60 : colIndex === 1 ? 120 : 100} \n                    height={20} \n                  />\n                </TableCell>\n              ))}\n            </TableRow>\n          ))}\n        </TableBody>\n      </Table>\n    </TableContainer>\n  );\n}\n\n/**\n * Default actions for dynamic records table\n */\nexport const DEFAULT_DYNAMIC_ACTIONS = [\n  {\n    key: 'view',\n    label: 'View',\n    icon: <ViewIcon fontSize=\"small\" />,\n    color: 'primary' as const,\n  },\n  {\n    key: 'edit',\n    label: 'Edit',\n    icon: <EditIcon fontSize=\"small\" />,\n    color: 'primary' as const,\n  },\n  {\n    key: 'history',\n    label: 'History',\n    icon: <HistoryIcon fontSize=\"small\" />,\n    color: 'info' as const,\n  },\n  {\n    key: 'download',\n    label: 'Download',\n    icon: <DownloadIcon fontSize=\"small\" />,\n    color: 'secondary' as const,\n  },\n  {\n    key: 'delete',\n    label: 'Delete',\n    icon: <DeleteIcon fontSize=\"small\" />,\n    color: 'error' as const,\n  },\n];\n\nexport default DynamicRecordsTable;\n","/**\n * TypeScript constants for record management across baptism, marriage, and funeral records\n */\n\n// Record types\nexport const RECORD_TYPES = {\n  BAPTISM: 'baptism',\n  MARRIAGE: 'marriage',\n  FUNERAL: 'funeral'\n} as const;\n\nexport type RecordType = typeof RECORD_TYPES[keyof typeof RECORD_TYPES];\n\n// Field types\nexport type FieldType = 'text' | 'email' | 'number' | 'date' | 'select' | 'multiselect' | 'textarea' | 'switch' | 'checkbox' | 'radio';\n\n// Field definition interface\nexport interface FieldDefinition {\n  name: string;\n  label: string;\n  type: FieldType;\n  required: boolean;\n  placeholder?: string;\n  options?: Array<{ value: any; label: string }>;\n  optionsSource?: string;\n  validation?: any;\n  helperText?: string;\n  gridSize?: { xs?: number; sm?: number; md?: number; lg?: number };\n}\n\n// Table column definition interface\nexport interface TableColumnDefinition {\n  field: string;\n  headerName: string;\n  width?: number | string;\n  cellRenderer?: string;\n  valueGetter?: (params: { data: any }) => any;\n}\n\n// Filter definition interface\nexport interface FilterDefinition {\n  name: string;\n  label: string;\n  type: 'text' | 'select' | 'date' | 'daterange' | 'multiselect';\n  options?: Array<{ value: any; label: string }>;\n  optionsSource?: string;\n}\n\n// Sort field definition interface\nexport interface SortFieldDefinition {\n  field: string;\n  label: string;\n}\n\n// Validation schema interface\nexport interface ValidationSchema {\n  [key: string]: {\n    required?: string;\n    min?: number;\n    max?: number;\n    message?: string;\n  };\n}\n\n// Certificate configuration interfaces\nexport interface CertificateFieldOffset {\n  x: number;\n  y: number;\n}\n\nexport interface CertificateConfig {\n  defaultFieldOffsets: Record<string, CertificateFieldOffset>;\n  defaultFontSizes: Record<string, number>;\n}\n\n// Main field definitions interface\nexport interface RecordFieldDefinitions {\n  fields: FieldDefinition[];\n  displayName: (record: any) => string;\n  sortFields: SortFieldDefinition[];\n  defaultSort: { field: string; direction: 'asc' | 'desc' };\n  filters: FilterDefinition[];\n  tableColumns: TableColumnDefinition[];\n  validationSchema: ValidationSchema;\n  certificateConfig: CertificateConfig;\n}\n\n// Field definitions for each record type\nexport const FIELD_DEFINITIONS: Record<RecordType, RecordFieldDefinitions> = {\n  [RECORD_TYPES.BAPTISM]: {\n    fields: [\n      { name: 'first_name', label: 'First Name', type: 'text', required: true },\n      { name: 'last_name', label: 'Last Name', type: 'text', required: true },\n      { name: 'birth_date', label: 'Birth Date', type: 'date', required: false },\n      { name: 'reception_date', label: 'Reception Date', type: 'date', required: true },\n      { name: 'birthplace', label: 'Birthplace', type: 'text', required: false },\n      { name: 'entry_type', label: 'Entry Type', type: 'select', required: false, options: [\n        { value: 'Baptism', label: 'Baptism' },\n        { value: 'Chrismation', label: 'Chrismation' },\n        { value: 'Transfer', label: 'Transfer' }\n      ]},\n      { name: 'sponsors', label: 'Sponsors', type: 'textarea', required: false },\n      { name: 'parents', label: 'Parents', type: 'textarea', required: true },\n      { name: 'clergy', label: 'Clergy', type: 'select', required: true, optionsSource: 'clergy' }\n    ],\n    displayName: (record) => `${record.first_name} ${record.last_name}`,\n    sortFields: [\n      { field: 'last_name', label: 'Name' },\n      { field: 'birth_date', label: 'Birth Date' },\n      { field: 'reception_date', label: 'Reception Date' },\n      { field: 'birthplace', label: 'Birthplace' },\n      { field: 'clergy', label: 'Clergy' }\n    ],\n    defaultSort: { field: 'reception_date', direction: 'desc' },\n    filters: [\n      { name: 'startDate', label: 'Start Date', type: 'date' },\n      { name: 'endDate', label: 'End Date', type: 'date' },\n      { name: 'birthplace', label: 'Birthplace', type: 'select', optionsSource: 'locations' },\n      { name: 'clergy', label: 'Clergy', type: 'select', optionsSource: 'clergy' },\n      { name: 'entry_type', label: 'Entry Type', type: 'select', options: [\n        { value: 'Baptism', label: 'Baptism' },\n        { value: 'Chrismation', label: 'Chrismation' },\n        { value: 'Transfer', label: 'Transfer' }\n      ]}\n    ],\n    tableColumns: [\n      { field: 'firstName', headerName: 'First Name' },\n      { field: 'lastName', headerName: 'Last Name' },\n      { field: 'dateOfBirth', headerName: 'Birth Date', cellRenderer: 'dateRenderer' },\n      { field: 'dateOfBaptism', headerName: 'Baptism Date', cellRenderer: 'dateRenderer' },\n      { field: 'placeOfBirth', headerName: 'Birthplace' },\n      { field: 'priest', headerName: 'Clergy' }\n    ],\n    validationSchema: {\n      first_name: { required: 'First name is required' },\n      last_name: { required: 'Last name is required' },\n      reception_date: { required: 'Reception date is required' },\n      parents: { required: 'Parents information is required' },\n      clergy: { required: 'Clergy is required' }\n    },\n    certificateConfig: {\n      defaultFieldOffsets: {\n        name: { x: 400, y: 335 },\n        birthplace: { x: 420, y: 350 },\n        birthDateMD: { x: 350, y: 605 },\n        birthDateY: { x: 550, y: 605 },\n        clergyBy: { x: 400, y: 425 },\n        churchName: { x: 430, y: 440 },\n        receptionDateMD: { x: 350, y: 460 },\n        receptionDateY: { x: 485, y: 460 },\n        sponsors: { x: 400, y: 475 },\n        rector: { x: 465, y: 505 }\n      },\n      defaultFontSizes: {\n        name: 18,\n        birthplace: 16,\n        birthDateMD: 16,\n        birthDateY: 16,\n        clergyBy: 16,\n        churchName: 16,\n        receptionDateMD: 16,\n        receptionDateY: 16,\n        sponsors: 16,\n        rector: 14\n      }\n    }\n  },\n  [RECORD_TYPES.MARRIAGE]: {\n    fields: [\n      { name: 'fname_groom', label: 'Groom First Name', type: 'text', required: true },\n      { name: 'lname_groom', label: 'Groom Last Name', type: 'text', required: true },\n      { name: 'fname_bride', label: 'Bride First Name', type: 'text', required: true },\n      { name: 'lname_bride', label: 'Bride Last Name', type: 'text', required: true },\n      { name: 'mdate', label: 'Marriage Date', type: 'date', required: true },\n      { name: 'parentsg', label: \"Groom's Parents\", type: 'textarea', required: false },\n      { name: 'parentsb', label: \"Bride's Parents\", type: 'textarea', required: false },\n      { name: 'witness', label: 'Witness', type: 'text', required: false },\n      { name: 'mlicense', label: 'Marriage License', type: 'text', required: false },\n      { name: 'clergy', label: 'Clergy', type: 'select', required: true, optionsSource: 'clergy' }\n    ],\n    displayName: (record) => `${record.fname_groom} ${record.lname_groom} & ${record.fname_bride} ${record.lname_bride}`,\n    sortFields: [\n      { field: 'lname_groom', label: 'Groom' },\n      { field: 'lname_bride', label: 'Bride' },\n      { field: 'mdate', label: 'Date' },\n      { field: 'clergy', label: 'Clergy' }\n    ],\n    defaultSort: { field: 'mdate', direction: 'desc' },\n    filters: [\n      { name: 'startDate', label: 'Start Date', type: 'date' },\n      { name: 'endDate', label: 'End Date', type: 'date' },\n      { name: 'clergy', label: 'Clergy', type: 'select', optionsSource: 'clergy' }\n    ],\n    tableColumns: [\n      { field: 'groomFirstName', headerName: 'Groom First Name' },\n      { field: 'groomLastName', headerName: 'Groom Last Name' },\n      { field: 'brideFirstName', headerName: 'Bride First Name' },\n      { field: 'brideLastName', headerName: 'Bride Last Name' },\n      { field: 'marriageDate', headerName: 'Marriage Date', cellRenderer: 'dateRenderer' },\n      { field: 'groomParents', headerName: \"Groom's Parents\" },\n      { field: 'brideParents', headerName: \"Bride's Parents\" },\n      { field: 'witnesses', headerName: 'Witnesses' },\n      { field: 'marriageLicense', headerName: 'Marriage License' },\n      { field: 'clergy', headerName: 'Clergy' }\n    ],\n    validationSchema: {\n      fname_groom: { required: 'Groom first name is required' },\n      lname_groom: { required: 'Groom last name is required' },\n      fname_bride: { required: 'Bride first name is required' },\n      lname_bride: { required: 'Bride last name is required' },\n      mdate: { required: 'Marriage date is required' },\n      clergy: { required: 'Clergy is required' }\n    },\n    certificateConfig: {\n      defaultFieldOffsets: {\n        groomName: { x: 397, y: 263 },\n        brideName: { x: 397, y: 299 },\n        clergyBy: { x: 397, y: 406 },\n        churchName: { x: 397, y: 442 },\n        marriageDateMD: { x: 350, y: 478 },\n        marriageDateY: { x: 550, y: 478 },\n        witness: { x: 397, y: 514 },\n        rector: { x: 397, y: 550 }\n      },\n      defaultFontSizes: {\n        groomName: 18,\n        brideName: 18,\n        clergyBy: 16,\n        churchName: 16,\n        marriageDateMD: 16,\n        marriageDateY: 16,\n        witness: 16,\n        rector: 14\n      }\n    }\n  },\n  [RECORD_TYPES.FUNERAL]: {\n    fields: [\n      { name: 'name', label: 'First Name', type: 'text', required: true },\n      { name: 'lastname', label: 'Last Name', type: 'text', required: true },\n      { name: 'deceased_date', label: 'Date of Death', type: 'date', required: true },\n      { name: 'burial_date', label: 'Burial Date', type: 'date', required: false },\n      { name: 'age', label: 'Age', type: 'number', required: false },\n      { name: 'burial_location', label: 'Burial Location', type: 'text', required: false },\n      { name: 'clergy', label: 'Clergy', type: 'select', required: true, optionsSource: 'clergy' }\n    ],\n    displayName: (record) => `${record.name} ${record.lastname}`,\n    sortFields: [\n      { field: 'lastname', label: 'Name' },\n      { field: 'deceased_date', label: 'Date of Death' },\n      { field: 'burial_date', label: 'Burial Date' },\n      { field: 'age', label: 'Age' },\n      { field: 'burial_location', label: 'Burial Location' },\n      { field: 'clergy', label: 'Clergy' }\n    ],\n    defaultSort: { field: 'deceased_date', direction: 'desc' },\n    filters: [\n      { name: 'startDate', label: 'Start Date', type: 'date' },\n      { name: 'endDate', label: 'End Date', type: 'date' },\n      { name: 'burial_location', label: 'Burial Location', type: 'select', optionsSource: 'locations' },\n      { name: 'clergy', label: 'Clergy', type: 'select', optionsSource: 'clergy' }\n    ],\n    tableColumns: [\n      { field: 'firstName', headerName: 'First Name' },\n      { field: 'lastName', headerName: 'Last Name' },\n      { field: 'dateOfDeath', headerName: 'Date of Death', cellRenderer: 'dateRenderer' },\n      { field: 'dateOfFuneral', headerName: 'Funeral Date', cellRenderer: 'dateRenderer' },\n      { field: 'age', headerName: 'Age', cellRenderer: 'numericColumn' },\n      { field: 'burialLocation', headerName: 'Burial Location' },\n      { field: 'clergy', headerName: 'Clergy' }\n    ],\n    validationSchema: {\n      name: { required: 'First name is required' },\n      lastname: { required: 'Last name is required' },\n      deceased_date: { required: 'Date of death is required' },\n      age: { min: 0, message: 'Age must be positive' },\n      clergy: { required: 'Clergy is required' }\n    },\n    certificateConfig: {\n      defaultFieldOffsets: {\n        fullName: { x: -100, y: -26 },\n        deathDate: { x: 22, y: -31 },\n        burialDate: { x: 12, y: -36 },\n        age: { x: 5, y: -34 },\n        clergy: { x: 5, y: -34 },\n        burialLocation: { x: 7, y: -34 }\n      },\n      defaultFontSizes: {\n        fullName: 18,\n        deathDate: 16,\n        burialDate: 16,\n        age: 14,\n        clergy: 16,\n        burialLocation: 16\n      }\n    }\n  }\n};\n\n// CSV export headers for each record type\nexport const CSV_HEADERS = {\n  [RECORD_TYPES.BAPTISM]: [\n    { label: 'First Name', key: 'first_name' },\n    { label: 'Last Name', key: 'last_name' },\n    { label: 'Birth Date', key: 'birth_date' },\n    { label: 'Reception Date', key: 'reception_date' },\n    { label: 'Birthplace', key: 'birthplace' },\n    { label: 'Entry Type', key: 'entry_type' },\n    { label: 'Sponsors', key: 'sponsors' },\n    { label: 'Parents', key: 'parents' },\n    { label: 'Clergy', key: 'clergy' }\n  ],\n  [RECORD_TYPES.MARRIAGE]: [\n    { label: 'Groom First Name', key: 'fname_groom' },\n    { label: 'Groom Last Name', key: 'lname_groom' },\n    { label: 'Bride First Name', key: 'fname_bride' },\n    { label: 'Bride Last Name', key: 'lname_bride' },\n    { label: 'Marriage Date', key: 'mdate' },\n    { label: 'Groom Parents', key: 'parentsg' },\n    { label: 'Bride Parents', key: 'parentsb' },\n    { label: 'Witness', key: 'witness' },\n    { label: 'Marriage License', key: 'mlicense' },\n    { label: 'Clergy', key: 'clergy' }\n  ],\n  [RECORD_TYPES.FUNERAL]: [\n    { label: 'First Name', key: 'name' },\n    { label: 'Last Name', key: 'lastname' },\n    { label: 'Date of Death', key: 'deceased_date' },\n    { label: 'Burial Date', key: 'burial_date' },\n    { label: 'Age', key: 'age' },\n    { label: 'Burial Location', key: 'burial_location' },\n    { label: 'Clergy', key: 'clergy' }\n  ]\n};\n\n// PDF document titles for each record type\nexport const PDF_TITLES = {\n  [RECORD_TYPES.BAPTISM]: 'Baptism Records',\n  [RECORD_TYPES.MARRIAGE]: 'Marriage Records',\n  [RECORD_TYPES.FUNERAL]: 'Funeral Records'\n};\n\n// Certificate file name templates for each record type\nexport const CERTIFICATE_FILENAMES = {\n  [RECORD_TYPES.BAPTISM]: (record: any) => `baptism_certificate_${record.first_name}_${record.last_name}.png`,\n  [RECORD_TYPES.MARRIAGE]: (record: any) => {\n    const groomName = `${record.fname_groom || ''}_${record.lname_groom || ''}`.trim().replace(/\\s+/g, '_');\n    const brideName = `${record.fname_bride || ''}_${record.lname_bride || ''}`.trim().replace(/\\s+/g, '_');\n    return `marriage_certificate_${groomName}_${brideName}.png`;\n  },\n  [RECORD_TYPES.FUNERAL]: (record: any) => {\n    const fullName = `${record.name || ''}_${record.lastname || ''}`.trim().replace(/\\s+/g, '_');\n    return `funeral_certificate_${fullName}.png`;\n  }\n};\n\n// Theme colors for each record type - Unified Orthodox Ocean Blue & Stained Gold Theme\nexport const THEME_COLORS = {\n  [RECORD_TYPES.BAPTISM]: {\n    gradient: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)', // Ocean blue gradient\n    header: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    search: 'linear-gradient(135deg, rgba(30, 58, 138, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%)',\n    table: 'rgba(255, 255, 255, 0.98)',\n    tableHeader: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    addButton: 'linear-gradient(135deg, #b45309 0%, #c8a951 100%)', // Stained gold button\n    accent: '#c8a951', // Stained gold\n    text: '#1e3a8a'\n  },\n  [RECORD_TYPES.MARRIAGE]: {\n    gradient: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)', // Same ocean blue gradient\n    header: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    search: 'linear-gradient(135deg, rgba(30, 58, 138, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%)',\n    table: 'rgba(255, 255, 255, 0.98)',\n    tableHeader: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    addButton: 'linear-gradient(135deg, #b45309 0%, #c8a951 100%)', // Stained gold button\n    accent: '#c8a951', // Stained gold\n    text: '#1e3a8a'\n  },\n  [RECORD_TYPES.FUNERAL]: {\n    gradient: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)', // Same ocean blue gradient\n    header: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    search: 'linear-gradient(135deg, rgba(30, 58, 138, 0.1) 0%, rgba(37, 99, 235, 0.05) 100%)',\n    table: 'rgba(255, 255, 255, 0.98)',\n    tableHeader: 'linear-gradient(135deg, #1e3a8a 0%, #2563eb 100%)',\n    addButton: 'linear-gradient(135deg, #b45309 0%, #c8a951 100%)', // Stained gold button\n    accent: '#c8a951', // Stained gold\n    text: '#1e3a8a'\n  }\n};\n\n// API endpoints for each record type\nexport const API_ENDPOINTS = {\n  [RECORD_TYPES.BAPTISM]: '/api/baptism-records',\n  [RECORD_TYPES.MARRIAGE]: '/api/marriage-records',\n  [RECORD_TYPES.FUNERAL]: '/api/funeral-records'\n};\n\n// Certificate endpoints for each record type\nexport const CERTIFICATE_ENDPOINTS = {\n  [RECORD_TYPES.BAPTISM]: '/api/certificate/baptism',\n  [RECORD_TYPES.MARRIAGE]: '/api/certificate/marriage',\n  [RECORD_TYPES.FUNERAL]: '/api/certificate/funeral'\n};\n","/**\n * Dynamic Records Manager\n * Automatically discovers and works with any om_church_## tables ending in _records\n * Uses column positions instead of field names\n */\n\nimport React, { useState, useMemo } from 'react';\nimport {\n  Box,\n  Typography,\n  Button,\n  Chip,\n  IconButton,\n  Tooltip,\n  Alert,\n  Paper,\n  Select,\n  MenuItem,\n  FormControl,\n  InputLabel,\n  CircularProgress,\n} from '@mui/material';\nimport {\n  Add as AddIcon,\n  Refresh as RefreshIcon,\n  Download as DownloadIcon,\n  Upload as UploadIcon,\n  Lock as LockIcon,\n  LockOpen as LockOpenIcon,\n  TableChart as TableIcon,\n  Settings as SettingsIcon,\n} from '@mui/icons-material';\n\n// Import dynamic components\nimport {\n  \n  \n  \n  useRecordTables,\n  useDynamicRecords,\n  useDynamicRecordMutations,\n  useDynamicRecordImportExport,\n  useTableColumns,\n  useFormFields,\n  useSearchFilters,\n  \n  \n} from './useDynamicRecords';\n\nimport DynamicRecordForm from './DynamicRecordForm';\nimport { RecordsSearch } from \"./RecordsSearch\";\nimport { RecordsModal } from \"./RecordsModal\";\nimport { DynamicRecordsTable } from \"./DynamicRecordsTable\";\nimport { THEME_COLORS } from '../constants';\n\n// Types\ninterface DynamicRecordsManagerProps {\n  churchId: string;\n  PDFDocument?: any;\n  ReadOnlyView?: React.ComponentType;\n}\n\nexport function DynamicRecordsManager({\n  churchId,\n  PDFDocument,\n  ReadOnlyView,\n}: DynamicRecordsManagerProps) {\n  // State management\n  const [selectedTable, setSelectedTable] = useState<string>('');\n  const [isLocked, setIsLocked] = useState(false);\n  const [selectedRecord, setSelectedRecord] = useState<any>(null);\n  const [showForm, setShowForm] = useState(false);\n  const [showImport, setShowImport] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [searchTerm, setSearchTerm] = useState(\"\");\n  const [filters, setFilters] = useState({});\n  const [sort, setSort] = useState({ field: \"\", direction: \"asc\" });\n  const [currentPage, setCurrentPage] = useState(1);\n  const [pageSize, setPageSize] = useState(10);\n\n  \n  \n\n  // Discover available tables\n  const { \n    tables, \n    isLoading: tablesLoading, \n    error: tablesError, \n    refetch: refetchTables \n  } = useRecordTables(churchId);\n\n  // Get table schema and columns\n  const { \n    columns, \n    isLoading: columnsLoading, \n    error: columnsError, \n    schema \n  } = useTableColumns(churchId, selectedTable);\n\n  // Get form fields\n  const { \n    fields, \n    isLoading: fieldsLoading \n  } = useFormFields(churchId, selectedTable);\n\n  // Get search filters\n  const { \n    filters: searchFilters \n  } = useSearchFilters(churchId, selectedTable);\n\n  // Data fetching\n  const {\n    records,\n    total,\n    page,\n    totalPages,\n    isLoading,\n    error,\n    refetch,\n  } = useDynamicRecords(churchId, selectedTable, {\n    filters: filters,\n    sort: sort,\n    pagination: { page: currentPage, limit: pageSize },\n    enabled: !!selectedTable,\n  });\n\n  // Mutations\n  const { create, update, delete: deleteRecord } = useDynamicRecordMutations(churchId, selectedTable);\n  const { import: importMutation, export: exportMutation } = useDynamicRecordImportExport(churchId, selectedTable);\n\n  // Theme colors (use default theme)\n  const themeColors = THEME_COLORS.baptism; // Use consistent theme\n\n  // Actions configuration\n  const actions = useMemo(() => [\n    {\n      key: 'view',\n      label: 'View',\n      icon: <span>👁️</span>,\n      color: 'primary' as const,\n    },\n    {\n      key: 'edit',\n      label: 'Edit',\n      icon: <span>✏️</span>,\n      color: 'primary' as const,\n    },\n    {\n      key: 'delete',\n      label: 'Delete',\n      icon: <span>🗑️</span>,\n      color: 'error' as const,\n    },\n  ], []);\n\n  // Event handlers\n  const handleTableChange = (tableName: string) => {\n    setSelectedTable(tableName);\n    setSearchTerm(\"\"); setFilters({}); setSort({ field: \"\", direction: \"asc\" });\n    setCurrentPage(1);\n  };\n\n  const handleSearch = () => {\n    refetch();\n  };\n\n  const handleClear = () => {\n    setSearchTerm(\"\"); setFilters({}); setSort({ field: \"\", direction: \"asc\" });\n    refetch();\n  };\n\n  const handleSort = (field: string, direction: 'asc' | 'desc') => {\n    setSort({ field, direction });\n  };\n\n  const handleRecordAction = (action: string, record: any) => {\n    switch (action) {\n      case 'view':\n        setSelectedRecord(record);\n        setShowForm(true);\n        break;\n      case 'edit':\n        setSelectedRecord(record);\n        setShowForm(true);\n        break;\n      case 'delete':\n        handleDeleteRecord(record);\n        break;\n    }\n  };\n\n  const handleDeleteRecord = async (record: any) => {\n    const recordId = record.id || record._id || record[Object.keys(record)[0]];\n    if (window.confirm(`Are you sure you want to delete this record?`)) {\n      try {\n        await deleteRecord.mutateAsync(recordId);\n        refetch();\n      } catch (error) {\n        console.error('Delete error:', error);\n      }\n    }\n  };\n\n  const handleFormSuccess = (record: any) => {\n    setShowForm(false);\n    setSelectedRecord(null);\n    refetch();\n  };\n\n  const handleFormError = (error: string) => {\n    console.error('Form error:', error);\n  };\n\n  const handleImport = async (file: File) => {\n    try {\n      await importMutation.mutateAsync({ file });\n      setShowImport(false);\n      refetch();\n    } catch (error) {\n      console.error('Import error:', error);\n    }\n  };\n\n  const handleExport = async (format: 'csv' | 'pdf' | 'excel') => {\n    try {\n      const result = await exportMutation.mutateAsync({ \n        format, \n        filters: filters \n      });\n      \n      if (result.success && result.data) {\n        // Create download link\n        const url = window.URL.createObjectURL(result.data);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = `${selectedTable}-export.${format}`;\n        link.click();\n        window.URL.revokeObjectURL(url);\n      }\n    } catch (error) {\n      console.error('Export error:', error);\n    }\n  };\n\n  const handleLockToggle = () => {\n    setIsLocked(!isLocked);\n  };\n\n  // Loading state for tables\n  if (tablesLoading) {\n    return (\n      <Box sx={{ p: 3, textAlign: 'center' }}>\n        <CircularProgress />\n        <Typography sx={{ mt: 2 }}>Discovering record tables...</Typography>\n      </Box>\n    );\n  }\n\n  // Error state for tables\n  if (tablesError) {\n    return (\n      <Alert severity=\"error\" sx={{ m: 2 }}>\n        Error discovering tables: {tablesError}\n        <Button onClick={() => refetchTables()} sx={{ ml: 2 }}>\n          Retry\n        </Button>\n      </Alert>\n    );\n  }\n\n  // No tables found\n  if (tables.length === 0) {\n    return (\n      <Box sx={{ p: 3, textAlign: 'center' }}>\n        <Typography variant=\"h6\" color=\"text.secondary\">\n          No record tables found\n        </Typography>\n        <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 1 }}>\n          Tables should be named with pattern: om_church_##_*_records\n        </Typography>\n        <Button onClick={() => refetchTables()} sx={{ mt: 2 }}>\n          Refresh\n        </Button>\n      </Box>\n    );\n  }\n\n  return (\n    <Box\n      sx={{\n        width: '100%',\n        height: '100%',\n        background: themeColors.gradient,\n        minHeight: '100vh',\n        p: 2,\n      }}\n    >\n      <Paper\n        elevation={3}\n        sx={{\n          borderRadius: 3,\n          overflow: 'hidden',\n          background: 'rgba(255, 255, 255, 0.95)',\n          backdropFilter: 'blur(10px)',\n        }}\n      >\n        {/* Header */}\n        <Box\n          sx={{\n            p: 3,\n            background: themeColors.header,\n            borderBottom: '1px solid rgba(0,0,0,0.1)',\n          }}\n        >\n          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>\n            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n              <TableIcon sx={{ color: 'white', fontSize: 32 }} />\n              <Typography variant=\"h4\" component=\"h1\" sx={{ fontWeight: 600, color: 'white' }}>\n                Dynamic Records Manager\n              </Typography>\n            </Box>\n            \n            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>\n              <Chip\n                label={isLocked ? 'Locked' : 'Unlocked'}\n                color={isLocked ? 'error' : 'success'}\n                icon={isLocked ? <LockIcon /> : <LockOpenIcon />}\n                sx={{ color: 'white' }}\n              />\n              \n              <Tooltip title=\"Toggle Lock\">\n                <IconButton onClick={handleLockToggle} sx={{ color: 'white' }}>\n                  {isLocked ? <LockIcon /> : <LockOpenIcon />}\n                </IconButton>\n              </Tooltip>\n            </Box>\n          </Box>\n\n          {/* Table Selection */}\n          <Box sx={{ mb: 2 }}>\n            <FormControl fullWidth sx={{ maxWidth: 400 }}>\n              <InputLabel sx={{ color: 'white' }}>Select Record Table</InputLabel>\n              <Select\n                value={selectedTable}\n                onChange={(e) => handleTableChange(e.target.value)}\n                label=\"Select Record Table\"\n                sx={{ \n                  color: 'white',\n                  '& .MuiOutlinedInput-notchedOutline': {\n                    borderColor: 'white',\n                  },\n                  '& .MuiSvgIcon-root': {\n                    color: 'white',\n                  },\n                }}\n              >\n                {tables.map((table) => (\n                  <MenuItem key={table.tableName} value={table.tableName}>\n                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n                      <TableIcon fontSize=\"small\" />\n                      <Box>\n                        <Typography variant=\"body1\">{table.displayName}</Typography>\n                        <Typography variant=\"caption\" color=\"text.secondary\">\n                          {table.tableName}\n                        </Typography>\n                      </Box>\n                    </Box>\n                  </MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n          </Box>\n\n          {/* Action Buttons */}\n          {selectedTable && (\n            <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>\n              <Button\n                variant=\"contained\"\n                startIcon={<AddIcon />}\n                onClick={() => setShowForm(true)}\n                disabled={isLocked}\n                sx={{\n                  background: themeColors.addButton,\n                  '&:hover': { background: themeColors.addButton, opacity: 0.9 }\n                }}\n              >\n                Add Record\n              </Button>\n              \n              <Button\n                variant=\"outlined\"\n                startIcon={<UploadIcon />}\n                onClick={() => setShowImport(true)}\n                disabled={isLocked}\n                sx={{ color: 'white', borderColor: 'white' }}\n              >\n                Import\n              </Button>\n              \n              <Button\n                variant=\"outlined\"\n                startIcon={<DownloadIcon />}\n                onClick={() => handleExport('csv')}\n                sx={{ color: 'white', borderColor: 'white' }}\n              >\n                Export CSV\n              </Button>\n              \n              <Button\n                variant=\"outlined\"\n                startIcon={<RefreshIcon />}\n                onClick={() => refetch()}\n                sx={{ color: 'white', borderColor: 'white' }}\n              >\n                Refresh\n              </Button>\n            </Box>\n          )}\n        </Box>\n\n        {/* Content */}\n        {selectedTable ? (\n          <>\n            {/* Search and Filters */}\n            <Box sx={{ p: 3, pb: 0 }}>\n              <RecordsSearch\n                searchTerm={searchTerm}\n                onSearchChange={setSearchTerm}\n                onSearch={handleSearch}\n                onClear={handleClear}\n                filters={searchFilters}\n                activeFilters={filters}\n                onFilterChange={setFilters}\n                onClearFilters={setFilters({})}\n                loading={isLoading}\n                resultsCount={total}\n                showFilters={true}\n                showResultsCount={true}\n                searchPlaceholder={`Search ${schema?.displayName || selectedTable} records...`}\n              />\n            </Box>\n\n            {/* Records Table */}\n            <Box sx={{ p: 3, pt: 0 }}>\n              {columnsLoading ? (\n                <DynamicRecordsTable \n                  columns={[]} \n                  records={[]} \n                  loading={true} \n                />\n              ) : columnsError ? (\n                <Alert severity=\"error\">\n                  Error loading table schema: {columnsError}\n                </Alert>\n              ) : (\n                <DynamicRecordsTable\n                  records={records}\n                  columns={columns}\n                  loading={isLoading}\n                  error={error}\n                  onRecordAction={handleRecordAction}\n                  onSort={handleSort}\n                  sortField={sort?.field}\n                  sortDirection={sort?.direction}\n                  actions={actions}\n                  showCheckboxes={!isLocked}\n                  showActions={!isLocked}\n                  emptyMessage={`No ${schema?.displayName || selectedTable} records found`}\n                  primaryKeyField={schema?.primaryKey}\n                />\n              )}\n            </Box>\n\n            {/* Pagination */}\n            <Box sx={{ p: 3, pt: 0, display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 2 }}>\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                Showing {records.length} of {total} records\n                (Page {page} of {totalPages})\n              </Typography>\n              \n              <Box sx={{ display: 'flex', gap: 1 }}>\n                <Button\n                  variant=\"outlined\"\n                  size=\"small\"\n                  onClick={pagination.prevPage}\n                  disabled={page <= 1}\n                >\n                  Previous\n                </Button>\n                <Button\n                  variant=\"outlined\"\n                  size=\"small\"\n                  onClick={pagination.nextPage}\n                  disabled={page >= totalPages}\n                >\n                  Next\n                </Button>\n              </Box>\n            </Box>\n          </>\n        ) : (\n          <Box sx={{ p: 3, textAlign: 'center' }}>\n            <Typography variant=\"h6\" color=\"text.secondary\">\n              Select a table to view records\n            </Typography>\n            <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 1 }}>\n              Choose from the dropdown above to start managing records\n            </Typography>\n          </Box>\n        )}\n      </Paper>\n\n      {/* Form Modal */}\n      {selectedTable && (\n        <DynamicRecordForm\n          churchId={churchId}\n          tableName={selectedTable}\n          open={showForm}\n          onClose={() => {\n            setShowForm(false);\n            setSelectedRecord(null);\n          }}\n          currentRecord={selectedRecord}\n          onSuccess={handleFormSuccess}\n          onError={handleFormError}\n        />\n      )}\n\n      {/* Import Modal */}\n      <RecordsModal\n        open={showImport}\n        onClose={() => setShowImport(false)}\n        title={`Import ${selectedTable} Records`}\n        maxWidth=\"sm\"\n      >\n        <Box sx={{ p: 2 }}>\n          <Typography variant=\"body1\" sx={{ mb: 2 }}>\n            Select a file to import records into {selectedTable}. Supported formats: CSV, Excel.\n          </Typography>\n          <input\n            type=\"file\"\n            accept=\".csv,.xlsx,.xls\"\n            onChange={(e) => {\n              const file = e.target.files?.[0];\n              if (file) handleImport(file);\n            }}\n          />\n        </Box>\n      </RecordsModal>\n    </Box>\n  );\n}\n\nexport default DynamicRecordsManager;\n"],"names":["ENDPOINTS","churchId","tableName","id","DynamicRecordsApiService","__publicField","__async","data","apiJson","table","error","filters","sort","pagination","params","key","value","url","__spreadProps","__spreadValues","record","recordData","searchTerm","file","options","formData","format","response","schema","transformedRecord","columnPositions","displayData","column","defaultMessage","message","FieldMapperApiError","createDynamicRecordsApiService","QUERY_KEYS","useRecordTables","apiService","useMemo","isLoading","refetch","useQuery","useTableSchema","useDynamicRecords","isFetching","_a","_b","_c","_d","useDynamicRecordMutations","queryClient","useQueryClient","createMutation","useMutation","updateMutation","_","deleteMutation","useDynamicRecordImportExport","importMutation","exportMutation","useTableColumns","b","columnValue","formatDisplayValue","useFormFields","mapColumnTypeToFormType","useSearchFilters","mapColumnTypeToFilterType","columnType","DynamicRecordForm","onSave","onCancel","jsx","DynamicRecordsTable","records","columns","loading","selectedRecords","onRecordSelect","onSelectAll","onRecordAction","onSort","sortField","sortDirection","actions","emptyMessage","className","showCheckboxes","showActions","dense","stickyHeader","maxHeight","primaryKeyField","anchorEl","setAnchorEl","useState","handleSort","field","handleActionClick","event","recordId","prev","handleActionClose","handleActionSelect","action","handleRecordSelect","selected","handleSelectAll","getRecordId","allSelected","someSelected","sortedColumns","a","DynamicRecordsTableSkeleton","Box","Alert","Typography","TableContainer","Paper","Table","TableHead","TableRow","TableCell","Checkbox","e","jsxs","Chip","TableBody","index","isSelected","menuAnchor","motion","getColumnValue","IconButton","MoreIcon","Menu","isDisabled","MenuItem","ListItemIcon","ListItemText","formatValue","columnName","type","rows","Skeleton","rowIndex","colIndex","RECORD_TYPES","THEME_COLORS","DynamicRecordsManager","PDFDocument","ReadOnlyView","selectedTable","setSelectedTable","isLocked","setIsLocked","selectedRecord","setSelectedRecord","showForm","setShowForm","showImport","setShowImport","showSettings","setShowSettings","setSearchTerm","setFilters","setSort","currentPage","setCurrentPage","pageSize","setPageSize","tables","tablesLoading","tablesError","refetchTables","columnsLoading","columnsError","searchFilters","total","page","totalPages","deleteRecord","themeColors","handleTableChange","handleSearch","handleClear","direction","handleRecordAction","handleDeleteRecord","handleFormSuccess","handleFormError","handleImport","handleExport","result","link","handleLockToggle","CircularProgress","Button","TableIcon","LockIcon","LockOpenIcon","Tooltip","FormControl","InputLabel","Select","AddIcon","UploadIcon","DownloadIcon","RefreshIcon","Fragment","RecordsSearch","RecordsModal"],"mappings":"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"}